/////////////////////////////////////////////////////////////////////////////// FILENAME:    SnapperSelectionProcessor.js// DATE:        9/14/2008// AUTHOR:      Joe Miller//// DESCRIPTION: Defines the class SnapperSelectionProcessor, which is capable//               of processing a selection into a snapped image.//// REFERENCES:  Result.js/////////////////////////////////////////////////////////////////////////////LSDev.Extensions.SnapperNS.SnapperSelectionProcessor = function() {        function createResult( success ) {        var message;                if( success ) {                        var messageCopied = document.getElementById( "snapper-strings" ).getString( "NotificationCopied" )            var messageSaved = document.getElementById( "snapper-strings" ).getString( "NotificationSaved" )            var messageCopiedAndSaved = document.getElementById( "snapper-strings" ).getString( "NotificationCopiedAndSaved" )            var messageFailed = document.getElementById( "snapper-strings" ).getString( "NotificationFailed" );                        var mode = LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getProcessingMode();            var useCopied = ((mode & 1) != 0);            var useSaved = ((mode & 2) != 0);                        if(useCopied) {                if(useSaved) {                    message = messageCopiedAndSaved;                }                else {                    message = messageCopied;                }            }            else if(useSaved) {                message = messageSaved;            }        }        else {            message = messageFailed;        }                return new LSDev.Common.Javascript.Util.Result( success, message );    }        var persistentFileTarget;    this.processSelection = function( selector ) {        var imageSnapper;        var snappedImage;        var success;                persistentFileTarget = null;                imageSnapper = new LSDev.Extensions.SnapperNS.CanvasImageSnapper();        snappedImage = imageSnapper.createSnappedImage( selector, window.content.document.URL );        success = true;                var mode = LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getProcessingMode();        if( (mode & 1) != 0 ) {            success = success && copySnappedImage( snappedImage );        }        if( (mode & 2) != 0 ) {            success = success && saveSnappedImage( snappedImage );        }                if( success && LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getEditSnappedImage() ) {            editSnappedImage( snappedImage );        }                return createResult( success );    }        function saveSnappedImage( image ) {        var wasSuccessful = true;        var fileTarget;                if( LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getAutoSave() ) {            fileTarget = new LSDev.Common.Javascript.FileTarget();            saveType = LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getAutoSaveImageType();                    fileTarget.path = LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getAutoSaveLocation();            fileTarget.filename = getDefaultFilename();            fileTarget.extension = getExtensionForSaveType( saveType );        }        else {            fileTarget = getSaveFileTarget();        }                // If we have all necessary information, save the file        if( fileTarget == null ||                fileTarget.path == "" ||                fileTarget.filename == "" ||                fileTarget.extension == "" ) {            wasSuccessful = false;        }        else {            var imageType = LSDev.Extensions.SnapperNS.SnappedImageTypes.findByFileExtension( fileTarget.extension );            image.toImageFile( fileTarget.path, fileTarget.filename, imageType );            wasSuccessful = true;        }                persistentFileTarget = fileTarget;                return wasSuccessful;    }        function editSnappedImage( snappedImage ) {        var fileTarget = persistentFileTarget;                // If we have all necessary information, save the file        if( null == fileTarget ||                "" == fileTarget.path ||                "" == fileTarget.filename ||                "" == fileTarget.extension ) {            fileTarget = new LSDev.Common.Javascript.FileTarget();            saveType = LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getAutoSaveImageType();                    fileTarget.path = LSDev.Extensions.SnapperNS.SnapperUtilities.TempDirectoryPath;            fileTarget.filename = getDefaultFilename();            fileTarget.extension = getExtensionForSaveType( saveType );                        LSDev.Extensions.SnapperNS.SnapperUtilities.EnsureTempDirectoryExists();                        var imageType = LSDev.Extensions.SnapperNS.SnappedImageTypes.findByFileExtension( fileTarget.extension );            snappedImage.toImageFile( fileTarget.path, fileTarget.filename, imageType);        }                openImageInEditor( fileTarget );    }        function openImageInEditor( fileTarget ) {            var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);            file.initWithPath(fileTarget.path);            file.append( fileTarget.filename + "." + fileTarget.extension );                        try {                // Try to open file using launch                setTimeout( function(){file.launch();}, 500 );            }            catch( ex ) {                // If launch didn't work, it might be because the OS doesn't yet have an implementation of it,                //  so try to let the OS figure out the best approach.                loadFile( file );            }    }        function loadFile( file )    {        var fileURI = Components.classes[ "@mozilla.org/network/io-service;1" ].getService( Components.interfaces.nsIIOService ).newFileURI( file );        var service = Components.classes[ "@mozilla.org/uriloader/external-protocol-service;1" ].getService( Components.interfaces.nsIExternalProtocolService );        service.loadUrl( fileURI );    }    function copySnappedImage( image ) {    	try {            var copier = new LSDev.Extensions.SnapperNS.HtmlSnappedImageCopier( window.content.document );            return copier.copy( image );    	}    	catch(ex) {    		alert(ex);    		    		return false;    	}    }        // Gets a default filename for a snapped image.    //    // RETURNS String    function getDefaultFilename() {        var today = new Date();        var filename = "snapper" + today.getTime();  // Need a unique filename... this should do                return filename;    }    // Gets a default file extension for a snapped image.    //    // RETURNS String    function getDefaultExtension() {        return LSDev.Extensions.SnapperNS.SnappedImageTypes.PNG.toFileExtension();    }        function getExtensionForSaveType( theSaveType ) {        var type;        switch( theSaveType ) {            case 1:                type = LSDev.Extensions.SnapperNS.SnappedImageTypes.JPG;                break;                        case 2:                type = LSDev.Extensions.SnapperNS.SnappedImageTypes.PNG;                break;                            default:                type = LSDev.Extensions.SnapperNS.SnappedImageTypes.JPG;        }                return type.toFileExtension();    }        function getImageTypeForSaveType( theSaveType ) {        switch( theSaveType ) {            case 1:                return LSDev.Extensions.SnapperNS.SnappedImageTypes.JPG;                        case 2:                return LSDev.Extensions.SnapperNS.SnappedImageTypes.PNG;                            default:                return LSDev.Extensions.SnapperNS.SnappedImageTypes.JPG;        }    }        // Gets the file to which the image will be saved, or NULL if one is not provided.    //    // RETURNS FileTarget    function getSaveFileTarget() {        var result;        var target = null;        var filePicker = Components.interfaces.nsIFilePicker;        var dialogSave = Components.classes[ "@mozilla.org/filepicker;1" ].createInstance( filePicker );        var dialogSaveTitle = document.getElementById('snapper-strings').getString("SaveAsTitle");        var defaultFilename = getDefaultFilename();        var imageTypes = LSDev.Extensions.SnapperNS.SnappedImageTypes.toArray();        var preferredExtension = getExtensionForSaveType( LSDev.Extensions.SnapperNS.SnapperUtilities.Preferences.getAutoSaveImageType() );        var defaultFilterIndex = 0;                dialogSave.init( window, dialogSaveTitle, filePicker.modeSave );        dialogSave.defaultString = defaultFilename;                for(var i = 0; i < imageTypes.length; i++ ) {            var ext = imageTypes[i].toFileExtension();                        if( ext == preferredExtension ) {                defaultFilterIndex = i;            }                        dialogSave.appendFilter( createFilterTitleForExtension( ext ), createFilterForExtension( ext ) );        }                dialogSave.filterIndex = defaultFilterIndex;                result = dialogSave.show();                if( filePicker.returnOK == result || filePicker.returnReplace == result ) {            target = new LSDev.Common.Javascript.FileTarget();                        target.path = dialogSave.file.parent.path;            target.filename = dialogSave.file.leafName;            target.extension = imageTypes[ dialogSave.filterIndex ].toFileExtension();        }                return target;    }        function createFilterTitleForExtension( ext ) {        return ext.toUpperCase() + " (*." + ext.toUpperCase() + ")";    }        function createFilterForExtension( ext ) {        return "*." + ext;    }}LSDev.Extensions.SnapperNS.SnapperSelectionProcessor.prototype = LSDev.Extensions.SnapperNS.SelectionProcessor;LSDev.Extensions.SnapperNS.SnapperSelectionProcessor.prototype.base = LSDev.Extensions.SnapperNS.SelectionProcessor;